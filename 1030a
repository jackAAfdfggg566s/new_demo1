好——下面给你几种安全性/实用性兼顾的做法，直接拿去用。

关键点摘要（先看要点）

把 GitLab CI 里的 base64 密文存在一个 CI 变量（例如 SSH_PASS_B64），并设置为 masked & protected。

不要把原始密码打印到日志。

尽量用 sshpass -f 文件（从临时文件读取）比 -p 更安全——因为 -p 会出现在 ps 命令的进程参数里。

更安全的方案是用 SSH key / deploy key，但如果必须用密码，下面示例覆盖常见场景。



---

1) 在 shell 脚本里（推荐：临时文件 + sshpass -f）

#!/usr/bin/env bash
set -euo pipefail

# 假定 GitLab CI / 环境变量里已有： SSH_PASS_B64
# 例如在 GitLab CI Variables 里设置 name=SSH_PASS_B64 value=<base64 编码的密码> (masked)

# 取得 base64 字符串
PASSWORD_B64="${SSH_PASS_B64:-}"   # 本地调试时可改为实际值

# 将 base64 解码写入临时文件（注意权限）
TMP_PASS_FILE="$(mktemp)" || exit 1
# Portable decode: GNU base64 使用 -d, macOS 使用 -D
if printf '%s' "$PASSWORD_B64" | base64 -d > "$TMP_PASS_FILE" 2>/dev/null; then
    true
elif printf '%s' "$PASSWORD_B64" | base64 -D > "$TMP_PASS_FILE" 2>/dev/null; then
    true
else
    echo "Error: base64 decode failed" >&2
    rm -f "$TMP_PASS_FILE"
    exit 1
fi

chmod 600 "$TMP_PASS_FILE"

# 使用 sshpass 从文件读取密码（不会把密码留在 ps 参数里）
# 其他 ssh 选项视需要添加，例如 -o StrictHostKeyChecking=no
sshpass -f "$TMP_PASS_FILE" ssh -o StrictHostKeyChecking=no user@remote.host.example 'uname -a; whoami'

# 用完删除临时文件
shred -u "$TMP_PASS_FILE" 2>/dev/null || rm -f "$TMP_PASS_FILE"

说明：

mktemp 创建的临时文件权限默认比较宽，故用 chmod 600 再限制。

shred -u 尝试安全删除，失败则用 rm -f。视你容器 / 平台是否支持 shred。

StrictHostKeyChecking=no 可以避免第一次交互式接受 host key，但生产环境慎用；推荐事先把 known_hosts 管好。



---

2) 直接用变量解码到内存并传给 sshpass -p（不推荐，简单但有风险）

DECODED_PASS="$(printf '%s' "$SSH_PASS_B64" | base64 -d)"
# 警告：-p 会在某些系统的 ps 输出中暴露命令行参数
sshpass -p "$DECODED_PASS" ssh user@remote.host 'hostname; id'

只在你能接受密码短时间暴露于进程列表时使用（几乎不建议在共享主机 / CI runner 上用）。


---

3) 在 GitLab CI job 中的示例

stages:
  - deploy

deploy_ssh:
  stage: deploy
  image: alpine:latest
  variables:
    # SSH_PASS_B64 在 GitLab CI Web UI 的 Variables 里设置为 base64 编码的密码，且标记为 "masked" 和 "protected"
  script:
    - apk add --no-cache openssh-client sshpass # 或者在镜像里已有
    - |
      # decode -> temp file -> ssh
      TMP="$(mktemp)"
      if printf '%s' "$SSH_PASS_B64" | base64 -d > "$TMP" 2>/dev/null; then
        chmod 600 "$TMP"
        sshpass -f "$TMP" ssh -o StrictHostKeyChecking=no user@host.example "echo connected: \$(hostname)"
        shred -u "$TMP" 2>/dev/null || rm -f "$TMP"
      else
        echo "base64 decode failed" >&2
        exit 1
      fi


---

4) 更安全的替代（强烈建议）

使用 SSH key（在 GitLab CI 的 "Deploy keys" 或使用 CI/CD variable 存放私钥内容，写入 ~/.ssh/id_rsa 并 chmod 600），然后直接 ssh（不需 sshpass）。这是最常规也是最安全的方法。

如果必须用密码并且远端支持 sudo 非交互密码或 API，则考虑使用更安全的认证方式（例如利用 Vault、Secrets Manager）。


示例：把私钥放为 SSH_PRIVATE_KEY（masked），在 CI job：

mkdir -p ~/.ssh
printf '%s' "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
chmod 600 ~/.ssh/id_rsa
ssh -o StrictHostKeyChecking=no user@host '...'


---

额外安全建议（不要忽略）

1. 在 GitLab 设置该变量为 masked + protected，并仅允许在受保护的分支/Runner 上使用。


2. CI 脚本中不要 echo 密码或解码后的内容。


3. 避免长时间把密码写到磁盘；如果必须写到临时文件，用 mktemp 且在用完立即删除。


4. 优先使用密钥或集中式 secret 管理（HashiCorp Vault / AWS Secrets Manager / GitLab Secrets 等）。


5. 在共享 runner 上不要用 sshpass -p，因为 ps 可能泄露。




---

如果你要，我可以直接：

把上面的脚本改成你现在用的脚本格式（你把现有脚本贴来），或

给你一个完整的 GitLab CI job（包含安装依赖、已遮蔽日志的写法），或

把示例改成把密码放到 ssh sshpass -f 的同时也自动处理 known_hosts 更安全的版本。


选一个，我直接给你成品。